#!/usr/bin/env python3
"""
Backtest AlphaBot complet - 10 ans de donn√©es historiques
Phase 5 : Validation performance sur donn√©es r√©elles
"""

import asyncio
import sys
import os
from datetime import datetime, timedelta
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path
import warnings
warnings.filterwarnings('ignore')

# Ajouter le r√©pertoire parent au path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

async def run_decade_backtest():
    """Backtest principal sur 10 ans (2014-2024)"""
    try:
        from alphabot.core.backtesting_engine import BacktestingEngine, BacktestConfig
        
        print("üöÄ BACKTEST ALPHABOT - D√âCENNIE 2014-2024")
        print("=" * 70)
        
        # Configuration compl√®te
        config = BacktestConfig(
            start_date="2014-01-01",
            end_date="2024-01-01", 
            initial_capital=100000.0,
            
            # Univers S&P 500 top 50
            universe=[
                # Technology
                "AAPL", "MSFT", "GOOGL", "AMZN", "NVDA", "META", "TSLA", "CRM", "ORCL", "ADBE",
                # Finance  
                "JPM", "BAC", "WFC", "GS", "MS", "C", "AXP", "BLK", "SPGI", "COF",
                # Healthcare
                "UNH", "JNJ", "PFE", "ABBV", "TMO", "ABT", "LLY", "MRK", "BMY", "AMGN",
                # Consumer
                "PG", "KO", "PEP", "WMT", "HD", "MCD", "NKE", "SBUX", "TGT", "LOW",
                # Industrial/Energy
                "BA", "CAT", "GE", "XOM", "CVX", "COP", "SLB", "EOG", "PSX", "VLO"
            ],
            
            # Param√®tres optimis√©s
            commission=0.001,  # 0.1%
            slippage_bps=5,    # 5 bps
            max_position_size=0.04,  # 4% max par titre
            max_sector_exposure=0.25, # 25% max par secteur
            max_leverage=0.95,        # 95% investi max
            
            benchmark="SPY"
        )
        
        print(f"üìä Configuration:")
        print(f"   P√©riode: {config.start_date} ‚Üí {config.end_date}")
        print(f"   Capital: ${config.initial_capital:,}")
        print(f"   Univers: {len(config.universe)} actifs")
        print(f"   Benchmark: {config.benchmark}")
        
        # Cr√©er engine et ex√©cuter
        engine = BacktestingEngine(config)
        
        print(f"\nüîÑ Chargement donn√©es historiques...")
        await engine.load_historical_data()
        
        print(f"\n‚ö° Ex√©cution backtest...")
        start_time = datetime.now()
        
        result = await engine.run_backtest()
        
        execution_time = datetime.now() - start_time
        print(f"\n‚è±Ô∏è Temps d'ex√©cution: {execution_time}")
        
        # Sauvegarder r√©sultats d√©taill√©s
        print(f"\nüíæ Sauvegarde r√©sultats...")
        engine.save_results(result, "backtests/decade_2014_2024")
        
        return result, config
        
    except Exception as e:
        print(f"‚ùå Erreur backtest: {e}")
        import traceback
        traceback.print_exc()
        return None, None

async def run_crisis_analysis():
    """Analyse performance durant les crises"""
    try:
        from alphabot.core.backtesting_engine import BacktestingEngine, BacktestConfig
        
        print(f"\nüö® ANALYSE CRISES FINANCI√àRES")
        print("=" * 50)
        
        crisis_periods = [
            {
                'name': 'Oil Crash 2014-2016',
                'start': '2014-06-01',
                'end': '2016-02-29',
                'description': 'Chute du p√©trole -75%'
            },
            {
                'name': 'China Crash 2015',
                'start': '2015-06-01', 
                'end': '2016-01-31',
                'description': 'Krach boursier chinois'
            },
            {
                'name': 'COVID-19 2020',
                'start': '2020-01-01',
                'end': '2020-12-31', 
                'description': 'Pand√©mie mondiale'
            },
            {
                'name': 'Inflation 2022',
                'start': '2022-01-01',
                'end': '2022-12-31',
                'description': 'Hausse taux Fed'
            },
            {
                'name': 'Bank Crisis 2023',
                'start': '2023-01-01',
                'end': '2023-06-30',
                'description': 'SVB, Credit Suisse'
            }
        ]
        
        crisis_results = []
        
        for crisis in crisis_periods:
            print(f"\nüìâ {crisis['name']} ({crisis['description']})")
            print(f"   P√©riode: {crisis['start']} ‚Üí {crisis['end']}")
            
            config = BacktestConfig(
                start_date=crisis['start'],
                end_date=crisis['end'],
                initial_capital=100000.0,
                universe=[
                    "AAPL", "MSFT", "GOOGL", "AMZN", "NVDA",
                    "JPM", "BAC", "XOM", "PG", "JNJ"
                ],  # Core holdings
                max_position_size=0.08,
                benchmark="SPY"
            )
            
            engine = BacktestingEngine(config)
            result = await engine.run_backtest()
            
            # Calculer survie vs benchmark
            outperformance = result.total_return - result.benchmark_return
            
            print(f"   üìä AlphaBot: {result.total_return:+.1%}")
            print(f"   üìä SPY:      {result.benchmark_return:+.1%}")
            print(f"   üìä Alpha:    {outperformance:+.1%}")
            print(f"   üìä Max DD:   {result.max_drawdown:.1%}")
            print(f"   üìä Sharpe:   {result.sharpe_ratio:.2f}")
            
            crisis_results.append({
                'name': crisis['name'],
                'period': f"{crisis['start']}/{crisis['end']}", 
                'alphabot_return': result.total_return,
                'spy_return': result.benchmark_return,
                'outperformance': outperformance,
                'max_drawdown': result.max_drawdown,
                'sharpe': result.sharpe_ratio
            })
        
        # Synth√®se crises
        avg_outperf = np.mean([r['outperformance'] for r in crisis_results])
        worst_dd = min([r['max_drawdown'] for r in crisis_results])
        crisis_wins = sum([1 for r in crisis_results if r['outperformance'] > 0])
        
        print(f"\nüìä SYNTH√àSE ANALYSE CRISES:")
        print(f"   Outperformance moyenne: {avg_outperf:+.1%}")
        print(f"   Pire drawdown:          {worst_dd:.1%}")
        print(f"   Crises gagnantes:       {crisis_wins}/{len(crisis_results)}")
        print(f"   R√©silience:             {'‚úÖ' if avg_outperf > 0 and worst_dd > -0.30 else '‚ùå'}")
        
        return crisis_results
        
    except Exception as e:
        print(f"‚ùå Erreur analyse crises: {e}")
        return []

async def run_sector_analysis():
    """Analyse performance par secteur"""
    try:
        from alphabot.core.backtesting_engine import BacktestingEngine, BacktestConfig
        
        print(f"\nüè≠ ANALYSE SECTORIELLE")
        print("=" * 30)
        
        sectors = {
            'Technology': ["AAPL", "MSFT", "GOOGL", "NVDA", "META", "ORCL", "CRM", "ADBE"],
            'Finance': ["JPM", "BAC", "WFC", "GS", "MS", "C", "AXP", "BLK"],
            'Healthcare': ["UNH", "JNJ", "PFE", "ABBV", "LLY", "MRK", "ABT", "TMO"], 
            'Consumer': ["PG", "KO", "WMT", "HD", "MCD", "NKE", "PEP", "SBUX"],
            'Energy': ["XOM", "CVX", "COP", "SLB", "EOG", "PSX", "VLO"]
        }
        
        sector_results = []
        
        for sector_name, symbols in sectors.items():
            print(f"\nüìä Secteur {sector_name}")
            
            config = BacktestConfig(
                start_date="2019-01-01",  # 5 ans pour rapidit√©
                end_date="2024-01-01",
                initial_capital=100000.0,
                universe=symbols,
                max_position_size=0.15,  # Plus concentr√© par secteur
                benchmark="SPY"
            )
            
            engine = BacktestingEngine(config)
            result = await engine.run_backtest()
            
            print(f"   Rendement: {result.annualized_return:+.1%}")
            print(f"   Sharpe:    {result.sharpe_ratio:.2f}")
            print(f"   Max DD:    {result.max_drawdown:.1%}")
            
            sector_results.append({
                'sector': sector_name,
                'return': result.annualized_return,
                'sharpe': result.sharpe_ratio,
                'max_dd': result.max_drawdown,
                'trades': result.total_trades
            })
        
        # Classement des secteurs
        sector_results.sort(key=lambda x: x['sharpe'], reverse=True)
        
        print(f"\nüèÜ CLASSEMENT SECTEURS (par Sharpe):")
        for i, sector in enumerate(sector_results, 1):
            print(f"   {i}. {sector['sector']:<12} Sharpe: {sector['sharpe']:.2f}, Rendement: {sector['return']:+.1%}")
        
        return sector_results
        
    except Exception as e:
        print(f"‚ùå Erreur analyse sectorielle: {e}")
        return []

def create_performance_report(result, config, crisis_results, sector_results):
    """G√©n√®re rapport de performance complet"""
    
    print(f"\nüìã RAPPORT DE PERFORMANCE COMPLET")
    print("=" * 70)
    
    # Performance globale
    print(f"\nüí∞ PERFORMANCE 10 ANS (2014-2024):")
    print(f"   Capital initial:       ${config.initial_capital:,}")
    print(f"   Capital final:         ${result.portfolio_value.iloc[-1]:,.0f}")
    print(f"   Rendement total:       {result.total_return:+.1%}")
    print(f"   Rendement annualis√©:   {result.annualized_return:+.1%}")
    print(f"   CAGR vs SPY:           {result.annualized_return - (result.benchmark_return * (10/10)):+.1%}")
    
    # M√©triques de risque
    print(f"\nüìä M√âTRIQUES DE RISQUE:")
    print(f"   Volatilit√© annuelle:   {result.volatility:.1%}")
    print(f"   Sharpe ratio:          {result.sharpe_ratio:.2f}")
    print(f"   Maximum drawdown:      {result.max_drawdown:.1%}")
    print(f"   Calmar ratio:          {result.calmar_ratio:.2f}")
    print(f"   Alpha vs SPY:          {result.alpha:+.1%}")
    print(f"   Beta vs SPY:           {result.beta:.2f}")
    print(f"   Information ratio:     {result.information_ratio:.2f}")
    
    # M√©triques de trading
    print(f"\n‚ö° M√âTRIQUES DE TRADING:")
    print(f"   Nombre total trades:   {result.total_trades:,}")
    print(f"   Taux de r√©ussite:      {result.win_rate:.1%}")
    print(f"   Rendement moyen/trade: {result.avg_trade_return:.2%}")
    print(f"   P√©riode d√©tention moy: {result.avg_holding_period:.1f} jours")
    
    # Validation objectifs
    print(f"\nüéØ VALIDATION OBJECTIFS ALPHABOT:")
    sharpe_target = 1.5
    dd_target = -0.15
    return_target = 0.12
    
    sharpe_ok = result.sharpe_ratio >= sharpe_target
    dd_ok = result.max_drawdown >= dd_target
    return_ok = result.annualized_return >= return_target
    
    print(f"   Sharpe ‚â• 1.5:          {'‚úÖ' if sharpe_ok else '‚ùå'} ({result.sharpe_ratio:.2f})")
    print(f"   Drawdown ‚â§ 15%:        {'‚úÖ' if dd_ok else '‚ùå'} ({result.max_drawdown:.1%})")
    print(f"   Rendement ‚â• 12%:       {'‚úÖ' if return_ok else '‚ùå'} ({result.annualized_return:.1%})")
    
    all_targets_met = sharpe_ok and dd_ok and return_ok
    
    # R√©sum√© crises
    if crisis_results:
        avg_crisis_alpha = np.mean([r['outperformance'] for r in crisis_results])
        crisis_resilience = avg_crisis_alpha > 0
        
        print(f"\nüö® R√âSILIENCE AUX CRISES:")
        print(f"   Alpha moyen en crise:  {avg_crisis_alpha:+.1%}")
        print(f"   R√©silience:            {'‚úÖ' if crisis_resilience else '‚ùå'}")
    
    # Meilleur secteur
    if sector_results:
        best_sector = sector_results[0]
        print(f"\nüèÜ MEILLEUR SECTEUR:")
        print(f"   {best_sector['sector']} (Sharpe: {best_sector['sharpe']:.2f})")
    
    # Conclusion
    print(f"\nüèÅ CONCLUSION:")
    if all_targets_met:
        print("   üéâ TOUS LES OBJECTIFS ATTEINTS!")
        print("   ‚úÖ AlphaBot pr√™t pour production")
        print("   üí∞ Recommandation: GO-LIVE avec capital limit√©")
    else:
        print("   ‚ö†Ô∏è Objectifs partiellement atteints")
        print("   üîß Optimisations n√©cessaires avant production")
        
        if not sharpe_ok:
            print("   üìä Am√©liorer Sharpe ratio (diversification, signaux)")
        if not dd_ok:
            print("   üõ°Ô∏è R√©duire drawdown (risk management)")
        if not return_ok:
            print("   üìà Augmenter rendement (signaux, allocation)")
    
    return all_targets_met

async def main():
    """Ex√©cution principale"""
    print("üî¨ BACKTEST COMPLET ALPHABOT - PHASE 5")
    print("Validation performance sur 10 ans de donn√©es r√©elles")
    print("=" * 70)
    
    # 1. Backtest principal 10 ans
    print("\n1Ô∏è‚É£ Backtest principal 10 ans...")
    result, config = await run_decade_backtest()
    
    if result is None:
        print("‚ùå √âchec backtest principal")
        return 1
    
    # 2. Analyse des crises
    print("\n2Ô∏è‚É£ Analyse performance durant crises...")
    crisis_results = await run_crisis_analysis()
    
    # 3. Analyse sectorielle  
    print("\n3Ô∏è‚É£ Analyse performance par secteur...")
    sector_results = await run_sector_analysis()
    
    # 4. Rapport final
    print("\n4Ô∏è‚É£ G√©n√©ration rapport final...")
    targets_met = create_performance_report(result, config, crisis_results, sector_results)
    
    # Cr√©er r√©pertoire de sortie
    output_dir = Path("backtests/reports")
    output_dir.mkdir(parents=True, exist_ok=True)
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Sauvegarder rapport JSON
    import json
    full_report = {
        'timestamp': timestamp,
        'backtest_period': f"{config.start_date} to {config.end_date}",
        'main_results': {
            'total_return': result.total_return,
            'annualized_return': result.annualized_return,
            'sharpe_ratio': result.sharpe_ratio,
            'max_drawdown': result.max_drawdown,
            'total_trades': result.total_trades,
            'win_rate': result.win_rate
        },
        'objectives_met': targets_met,
        'crisis_analysis': crisis_results,
        'sector_analysis': sector_results
    }
    
    with open(output_dir / f"full_report_{timestamp}.json", 'w') as f:
        json.dump(full_report, f, indent=2, default=str)
    
    print(f"\nüíæ Rapport complet sauvegard√©: backtests/reports/full_report_{timestamp}.json")
    
    if targets_met:
        print("\nüéâ PHASE 5 R√âUSSIE - VALIDATION COMPL√àTE!")
        print("üöÄ AlphaBot pr√™t pour Phase 6 (Production)")
        return 0
    else:
        print("\n‚ö†Ô∏è Optimisations n√©cessaires")
        print("üîß Retour Phase 4 pour ajustements")
        return 1

if __name__ == "__main__":
    exit_code = asyncio.run(main())